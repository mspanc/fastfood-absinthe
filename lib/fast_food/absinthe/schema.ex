defmodule FastFood.Absinthe.Schema do
  @type parent() :: struct()
  @type record() :: struct()
  @type context() :: map()

  @callback before_query(Ecto.Queryable.t(), context()) :: Ecto.Queryable.t()
  @callback after_query(record(), context()) :: record()
  @callback before_create(Ecto.Changeset.t(), context()) :: Ecto.Changeset.t()
  @callback after_create(record(), context()) :: any()
  @callback before_update(Ecto.Changeset.t(), context()) :: Ecto.Changeset.t()
  @callback after_update(record(), context()) :: any()
  @callback before_delete(record(), context()) :: any()
  @callback after_delete(record(), context()) :: any()

  @optional_callbacks before_query: 2,
                      after_query: 2,
                      before_create: 2,
                      after_create: 2,
                      before_update: 2,
                      after_update: 2,
                      before_delete: 2,
                      after_delete: 2

  defmacro __using__(_opts \\ []) do
    quote do
      use Ecto.Schema
      @behaviour FastFood.Absinthe.Schema
      import FastFood.Absinthe.Schema, only: [fastfood_schema: 2]
    end
  end

  @doc """
  Works the same as `Ecto.Schema.schema/2` but allows to add extra `:graphql`
  option to each field that can be used to customize the autogenerated
  GraphQL schema.

  The `:graphql` option, if present, should contain a keyword list.

  Supported options within given keyword list are:

  - `:non_null` - boolean - whether the field should be marked as non null.
    GraphQL treats all fields as nullable by default so if you want to
    mark them as non-nullable in the API, use this option.
  """
  defmacro fastfood_schema(source, do: block) do
    # Define a function to handle the transformation
    transform = fn
      # Match a call to `field` with its arguments
      {:field, _, args}, acc when is_list(args) ->
        field_name = hd(args)

        # Ensure the last argument is a list (keyword list)
        case List.last(args) do
          kw when is_list(kw) ->
            # Remove the :graphql key from the keyword list
            {graphql_opts, updated_kw} =
              case Keyword.pop(kw, :graphql) do
                {nil, kw} ->
                  {[], kw}

                {opts, kw} ->
                  {opts, kw}
              end

            # Replace the old keyword list with the updated one
            updated_args = List.update_at(args, length(args) - 1, fn _ -> updated_kw end)

            # Return the updated call to `field` and accumulate graphql_opts
            {{:field, [], updated_args}, [{field_name, graphql_opts} | acc]}

          _ ->
            # If the last argument is not a list, return the call unchanged
            # Accumulate empty graphql opts
            {{:field, [], args}, [{field_name, []} | acc]}
        end

      other, acc ->
        # Pass through other calls
        {other, acc}
    end

    # Use Macro.postwalk to apply the transformation to the entire block
    {updated_block, fields_with_graphql_opts} = Macro.postwalk(block, [], transform)

    schema =
      quote do
        schema unquote(source) do
          unquote(updated_block)
        end
      end

    non_nulls =
      for {field_name, graphql_opts} <- fields_with_graphql_opts do
        if Keyword.has_key?(graphql_opts, :non_null) do
          quote do
            def __fastfood__(:non_null, unquote(field_name)), do: unquote(graphql_opts[:non_null])
          end
        else
          quote do
            def __fastfood__(:non_null, unquote(field_name)), do: false
          end
        end
      end

    non_nulls_default =
      quote do
        def __fastfood__(:non_null, _field_name), do: nil
      end

    [schema, non_nulls, non_nulls_default]
  end
end
