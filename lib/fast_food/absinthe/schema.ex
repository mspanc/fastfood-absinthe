defmodule FastFood.Absinthe.Schema do
  @type parent() :: struct()
  @type record() :: struct()
  @type context() :: map()

  @callback before_query(Ecto.Queryable.t(), context()) :: Ecto.Queryable.t()
  @callback after_query(record(), context()) :: record()
  @callback before_create(Ecto.Changeset.t(), context()) :: Ecto.Changeset.t()
  @callback after_create(record(), context()) :: any()
  @callback before_update(Ecto.Changeset.t(), context()) :: Ecto.Changeset.t()
  @callback after_update(record(), context()) :: any()
  @callback before_delete(record(), context()) :: any()
  @callback after_delete(record(), context()) :: any()

  @optional_callbacks before_query: 2,
                      after_query: 2,
                      before_create: 2,
                      after_create: 2,
                      before_update: 2,
                      after_update: 2,
                      before_delete: 2,
                      after_delete: 2

  defmacro __using__(_opts \\ []) do
    quote do
      use Ecto.Schema
      @behaviour FastFood.Absinthe.Schema
      import FastFood.Absinthe.Schema, only: [fastfood_schema: 2]
    end
  end

  @doc """
  Works the same way as `Ecto.Schema.schema/2` but allows to add extra `:graphql`
  option to each field that can be used to customize the autogenerated
  GraphQL schema.

  The `:graphql` option, if present, should contain a keyword list.

  Supported options within given keyword list are:

  - `:non_null` - boolean - whether the field should be marked as non null.
    GraphQL treats all fields as nullable by default so if you want to
    mark them as non-nullable in the API, use this option.
  """
  defmacro fastfood_schema(source, do: block) do
    # Use Macro.postwalk to apply the transformation to the entire block
    {updated_block, fastfood_schema_opts} =
      Macro.postwalk(
        block,
        %{
          field: [],
          belongs_to: []
        },
        &extract_graphql_opts/2
      )

    schema =
      quote do
        schema unquote(source) do
          unquote(updated_block)
        end
      end

    non_nulls =
      for {field_name, graphql_opts} <- fastfood_schema_opts.field do
        if Keyword.has_key?(graphql_opts, :non_null) do
          quote do
            def __fastfood__(:non_null, unquote(field_name)), do: unquote(graphql_opts[:non_null])
          end
        else
          quote do
            def __fastfood__(:non_null, unquote(field_name)), do: false
          end
        end
      end

    non_nulls_default =
      quote do
        def __fastfood__(:non_null, field) do
          # Check if field being queried is not a field that is related to any belongs_to
          # association. If yes, use the same setting as the association.
          belongs_to_parent =
            __schema__(:associations)
            |> Enum.find(fn assoc_name ->
              case __schema__(:association, assoc_name) do
                %Ecto.Association.BelongsTo{
                  field: belongs_to_parent,
                  owner_key: ^field
                } ->
                  belongs_to_parent

                _ ->
                  false
              end
            end)

          if belongs_to_parent do
            __fastfood__(:non_null, belongs_to_parent)
          else
            # If field was not found, return null
            nil
          end
        end
      end

    [schema, non_nulls, non_nulls_default]
  end

  # Extract options for fields, embeds one and belongs_to associations.
  #
  # In case of belongs_to association we need to apply non-null to both field
  # that holds ID as well as the association, which are two distinct fields
  # in GraphQL.
  #
  # In order to avoid replication Ecto logic, we just store that this association
  # has certain GraphQL options (if present), but defer resolution to after
  # Ecto.Schema.__schema__/2 is called so we have access to the schema metadata.
  defp extract_graphql_opts({field_type, _, [field_name | opts]}, acc)
       when field_type in [:field, :embeds_one, :belongs_to] do
    {field_graphql_opts, updated_opts} =
      pop_graphql_opt(opts)

    {{field_type, [], [field_name | updated_opts]},
     %{acc | field: [{field_name, field_graphql_opts} | acc.field]}}
  end

  # Pass other schema definitions unchanged.
  defp extract_graphql_opts(other, acc) do
    {other, acc}
  end

  # Removes graphql option from keyword list (if present).
  # Returns removed option and rest of the keyword list.
  defp pop_graphql_opt(opts) when is_list(opts) do
    # Ensure the last argument is a list (keyword list)
    case List.last(opts) do
      kw when is_list(kw) ->
        # Remove the :graphql key from the keyword list
        {graphql_opts, updated_kw} =
          case Keyword.pop(kw, :graphql) do
            {nil, kw} ->
              {[], kw}

            {opts, kw} ->
              {opts, kw}
          end

        # Replace the old keyword list with the updated one
        {graphql_opts, List.update_at(opts, length(opts) - 1, fn _ -> updated_kw end)}

      _ ->
        {[], opts}
    end
  end
end
