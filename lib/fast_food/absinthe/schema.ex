defmodule FastFood.Absinthe.Schema do
  @type parent() :: struct()
  @type record() :: struct()
  @type context() :: map()

  @callback before_query(Ecto.Queryable.t(), context()) :: Ecto.Queryable.t()
  @callback after_query(record(), context()) :: record()
  @callback before_create(Ecto.Changeset.t(), context()) :: Ecto.Changeset.t()
  @callback after_create(record(), context()) :: any()
  @callback before_update(Ecto.Changeset.t(), context()) :: Ecto.Changeset.t()
  @callback after_update(record(), context()) :: any()
  @callback before_delete(record(), context()) :: any()
  @callback after_delete(record(), context()) :: any()

  @optional_callbacks before_query: 2,
                      after_query: 2,
                      before_create: 2,
                      after_create: 2,
                      before_update: 2,
                      after_update: 2,
                      before_delete: 2,
                      after_delete: 2

  defmacro __using__(_opts \\ []) do
    quote do
      use Ecto.Schema
      @behaviour FastFood.Absinthe.Schema
      import FastFood.Absinthe.Schema, only: [fastfood_schema: 2, fastfood_embedded_schema: 1]
    end
  end

  defp pre(block) do
    Macro.postwalk(
      block,
      %{
        field: []
      },
      &extract_graphql_opts/2
    )
  end

  defp post(fastfood_schema_opts) do
    non_nulls =
      for {field_name, graphql_opts} <- fastfood_schema_opts.field do
        if Keyword.has_key?(graphql_opts, :non_null) do
          quote do
            def __fastfood__(:non_null, unquote(field_name)), do: unquote(graphql_opts[:non_null])
          end
        else
          quote do
            def __fastfood__(:non_null, unquote(field_name)), do: false
          end
        end
      end

    # For most fields the dedicated function defined in the macro above will catch.
    # But in some cases we need to do some run-time checks.
    non_nulls_catchall =
      quote do
        def __fastfood__(:non_null, field) do
          # Check if field being queried is not a field that is related to any belongs_to
          # association. If yes, use the same setting as the association.
          belongs_to_parent =
            __schema__(:associations)
            |> Enum.find(fn assoc_name ->
              case __schema__(:association, assoc_name) do
                %Ecto.Association.BelongsTo{
                  field: belongs_to_parent,
                  owner_key: ^field
                } ->
                  belongs_to_parent

                _ ->
                  false
              end
            end)

          if belongs_to_parent do
            __fastfood__(:non_null, belongs_to_parent)
          else
            # Check if field is not a primary key, then it is always non-null
            if Enum.member?(__schema__(:primary_key), field) do
              true
            else
              # Check if field is not autogenerated, then it is always non-null
              if Enum.member?(__schema__(:autogenerate_fields), field) do
                true
              else
                # If none of rules above matched, field is unknown
                nil
              end
            end
          end
        end
      end

    [non_nulls, non_nulls_catchall]
  end

  @doc """
  Works in the same way as `Ecto.Schema.schema/2` but allows to add extra
  `:graphql` option to some fields so it can be used to customize the
  autogenerated GraphQL schema.

  The `:graphql` option can currently be added to field, embeds_one and
  belongs_to.

  The `:graphql` option, if present, should contain a keyword list.

  Supported options within given keyword list are:

  - `:non_null` - boolean - whether the field should be marked as non null.
    GraphQL treats all fields as nullable by default so if you want to
    mark them as non-nullable in the API, use this option.
  """
  defmacro fastfood_schema(source, do: block) do
    {updated_block, fastfood_schema_opts} =
      pre(block)

    schema =
      quote do
        schema unquote(source) do
          unquote(updated_block)
        end
      end

    post_code = post(fastfood_schema_opts)

    [schema | post_code]
  end

  @doc """
  Works in the same way as `Ecto.Schema.embedded_schema/1` but allows to
  add extra `:graphql` option to some fields so it can be used to customize
  the autogenerated GraphQL schema.

  See `fastfood_schema/2` for more information.
  """
  defmacro fastfood_embedded_schema(do: block) do
    {updated_block, fastfood_schema_opts} =
      pre(block)

    schema =
      quote do
        embedded_schema do
          unquote(updated_block)
        end
      end

    post_code = post(fastfood_schema_opts)

    [schema | post_code]
  end

  # Extract options for fields, embeds one and belongs_to associations.
  #
  # In case of belongs_to association we need to apply non-null to both field
  # that holds ID as well as the association, which are two distinct fields
  # in GraphQL.
  #
  # In order to avoid replication Ecto logic, we just store that this association
  # has certain GraphQL options (if present), but defer resolution to after
  # Ecto.Schema.__schema__/2 is called so we have access to the schema metadata.
  defp extract_graphql_opts({field_type, _, [field_name | opts]}, acc)
       when field_type in [:field, :embeds_one, :belongs_to] do
    {field_graphql_opts, updated_opts} =
      pop_graphql_opt(opts)

    {{field_type, [], [field_name | updated_opts]},
     %{acc | field: [{field_name, field_graphql_opts} | acc.field]}}
  end

  # Pass other schema definitions unchanged.
  defp extract_graphql_opts(other, acc) do
    {other, acc}
  end

  # Removes graphql option from keyword list (if present).
  # Returns removed option and rest of the keyword list.
  defp pop_graphql_opt(opts) when is_list(opts) do
    # Ensure the last argument is a list (keyword list)
    case List.last(opts) do
      kw when is_list(kw) ->
        # Remove the :graphql key from the keyword list
        {graphql_opts, updated_kw} =
          case Keyword.pop(kw, :graphql) do
            {nil, kw} ->
              {[], kw}

            {opts, kw} ->
              {opts, kw}
          end

        # Replace the old keyword list with the updated one
        {graphql_opts, List.update_at(opts, length(opts) - 1, fn _ -> updated_kw end)}

      _ ->
        {[], opts}
    end
  end
end
